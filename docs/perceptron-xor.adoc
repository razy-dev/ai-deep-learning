include::_toc.adoc[]

= Perception XOR

== XOR Gate
[cols="^1,^1,^1"]
// , %autowidth.stretch]
|====
| stem:[x_1] | stem:[x_2] | y

| 0 | 0 | 0
| 0 | 1 | 1
| 1 | 0 | 1
| 1 | 1 | 0
|====

image::perceptron-xor.png[align=center]

[.text-center]
stem:[y =
  \begin{cases}
    0 \quad (w_1 \times 0 + w_2 \times 0 + b \leq 0) = b \leq 0         \\
    1 \quad (w_1 \times 0 + w_2 \times 1 + b > 0)    = w_2 + b > 0      \\
    1 \quad (w_1 \times 1 + w_2 \times 0 + b > 0)    = w_1 + b > 0      \\
    0 \quad (w_1 \times 1 + w_2 \times 1 + b \leq 0) = w_1 + w_2 \leq 0 \\
  \end{cases}
]

image::perceptron-xor-gate.png[align=center]

=== Implement
[source,python]
----
include::{sourcedir}/perceptron/percept.py[]
----

.result
----
[ x1 = 2, x2 = 1 ] : 0.5 = 0.1 * 2 + 0.3 * 1 <= 0.6, return 0
[ x1 = 3, x2 = 1 ] : 0.6 = 0.1 * 3 + 0.3 * 1 <= 0.6, return 0
[ x1 = 4, x2 = 1 ] : 0.7 = 0.1 * 4 + 0.3 * 1  > 0.6, return 1
----

== Logic Gates
image::logic-gates.png[align=center]

=== AND Gate
[cols="^1,^1,^1"]
// , %autowidth.stretch]
|====
| stem:[x_1] | stem:[x_2] | y

| 0 | 0 | 0
| 0 | 1 | 0
| 1 | 0 | 0
| 1 | 1 | 1
|====

[source,python]
----
include::{sourcedir}/perceptron/perceptron-and.py[]
----

.result
----
...

w1 = 0.5, w2 = 0.5, theta=1
[ x1 = 0, x2 = 0 ] : 0.0 = 0.5 * 0 + 0.5 * 0 <= 1, return 0
[ x1 = 0, x2 = 1 ] : 0.5 = 0.5 * 0 + 0.5 * 1 <= 1, return 0
[ x1 = 1, x2 = 0 ] : 0.5 = 0.5 * 1 + 0.5 * 0 <= 1, return 0
[ x1 = 1, x2 = 1 ] : 1.0 = 0.5 * 1 + 0.5 * 1 <= 1, return 0

w1 = 0.6, w2 = 0.6, theta=1
[ x1 = 0, x2 = 0 ] : 0.0 = 0.6 * 0 + 0.6 * 0 <= 1, return 0
[ x1 = 0, x2 = 1 ] : 0.6 = 0.6 * 0 + 0.6 * 1 <= 1, return 0
[ x1 = 1, x2 = 0 ] : 0.6 = 0.6 * 1 + 0.6 * 0 <= 1, return 0
[ x1 = 1, x2 = 1 ] : 1.2 = 0.6 * 1 + 0.6 * 1  > 1, return 1

...
----

=== NAND Gate
[cols="^1,^1,^1"]
// , %autowidth.stretch]
|====
| stem:[x_1] | stem:[x_2] | y

| 0 | 0 | 1
| 0 | 1 | 1
| 1 | 0 | 1
| 1 | 1 | 0
|====

[source,python]
----
include::{sourcedir}/perceptron/perceptron-nand.py[]
----

.result
----
w1 = -1.0, w2 = -1.0, theta=-1
[ x1 = 0, x2 = 0 ] : -0.0 = -1.0 * 0 + -1.0 * 0  > -1, return 1
[ x1 = 0, x2 = 1 ] : -1.0 = -1.0 * 0 + -1.0 * 1 <= -1, return 0
[ x1 = 1, x2 = 0 ] : -1.0 = -1.0 * 1 + -1.0 * 0 <= -1, return 0
[ x1 = 1, x2 = 1 ] : -2.0 = -1.0 * 1 + -1.0 * 1 <= -1, return 0

w1 = -0.9, w2 = -0.9, theta=-1
[ x1 = 0, x2 = 0 ] : -0.0 = -0.9 * 0 + -0.9 * 0  > -1, return 1
[ x1 = 0, x2 = 1 ] : -0.9 = -0.9 * 0 + -0.9 * 1  > -1, return 1
[ x1 = 1, x2 = 0 ] : -0.9 = -0.9 * 1 + -0.9 * 0  > -1, return 1
[ x1 = 1, x2 = 1 ] : -1.8 = -0.9 * 1 + -0.9 * 1 <= -1, return 0

...

w1 = -0.4, w2 = -0.4, theta=-1
[ x1 = 0, x2 = 0 ] : -0.0 = -0.4 * 0 + -0.4 * 0  > -1, return 1
[ x1 = 0, x2 = 1 ] : -0.4 = -0.4 * 0 + -0.4 * 1  > -1, return 1
[ x1 = 1, x2 = 0 ] : -0.4 = -0.4 * 1 + -0.4 * 0  > -1, return 1
[ x1 = 1, x2 = 1 ] : -0.8 = -0.4 * 1 + -0.4 * 1  > -1, return 1
----

=== OR Gate
[cols="^1,^1,^1"]
// , %autowidth.stretch]
|====
| stem:[x_1] | stem:[x_2] | y

| 0 | 0 | 0
| 0 | 1 | 1
| 1 | 0 | 1
| 1 | 1 | 1
|====

[source,python]
----
include::{sourcedir}/perceptron/perceptron-or.py[]
----

.result
----
...
w1 = 0.5, w2 = 0.5, theta=0.5
[ x1 = 0, x2 = 0 ] : 0.0 = 0.5 * 0 + 0.5 * 0 <= 0.5, return 0
[ x1 = 0, x2 = 1 ] : 0.5 = 0.5 * 0 + 0.5 * 1 <= 0.5, return 0
[ x1 = 1, x2 = 0 ] : 0.5 = 0.5 * 1 + 0.5 * 0 <= 0.5, return 0
[ x1 = 1, x2 = 1 ] : 1.0 = 0.5 * 1 + 0.5 * 1  > 0.5, return 1

w1 = 0.6, w2 = 0.6, theta=0.5
[ x1 = 0, x2 = 0 ] : 0.0 = 0.6 * 0 + 0.6 * 0 <= 0.5, return 0
[ x1 = 0, x2 = 1 ] : 0.6 = 0.6 * 0 + 0.6 * 1  > 0.5, return 1
[ x1 = 1, x2 = 0 ] : 0.6 = 0.6 * 1 + 0.6 * 0  > 0.5, return 1
[ x1 = 1, x2 = 1 ] : 1.2 = 0.6 * 1 + 0.6 * 1  > 0.5, return 1
...
----